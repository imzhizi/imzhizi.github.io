<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tycho on Breeze Bless U</title><link>https://imzhizi.com/categories/tycho/</link><description>Recent content in Tycho on Breeze Bless U</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 07 Mar 2020 01:10:48 +0800</lastBuildDate><atom:link href="https://imzhizi.com/categories/tycho/index.xml" rel="self" type="application/rss+xml"/><item><title>个人对于 Maven 的理解</title><link>https://imzhizi.com/2020/03/%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8E-maven-%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Sat, 07 Mar 2020 01:10:48 +0800</pubDate><guid>https://imzhizi.com/2020/03/%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8E-maven-%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>&lt;p>Maven 一直都在使用, 但如果说是不是真的懂 Maven, 很难谈得上. 或许什么时候系统地学习一下, 但在那之前, 打算先记下自己目前对于 Maven 的理解, 之后再进行对比, 看有哪些疏漏和错误.&lt;/p>
&lt;h3 id="maven-基础">Maven 基础&lt;/h3>
&lt;p>最直观的, Maven 使用 pom.xml 文件来管理项目中所使用的依赖, 这跟 Python 的 requirement.txt、JS 的 &lt;code>package.json&lt;/code> 或者是 Ruby 的 &lt;code>Gemfile&lt;/code> 都类似.&lt;/p>
&lt;p>不过, 其他语言的依赖文件规定的往往是某个包的最低版本, 在实际安装的时候, 很可能会安装最新版, 这个时候实际版本会形成另外一个 lock 文件, 像 &lt;code>package.json.lock&lt;/code>. 但是 Maven 不会, 因为在 Maven 的一个依赖节点中, 会要求声明具体的版本.&lt;/p>
&lt;p>其次, 因为和构建相关, 所以 pom.xml 中需要声明项目所属的组织、项目的名称、版本, 同时还要在 &lt;code>properties&lt;/code> 节点中声明使用的 Java 版本、编码等信息, &lt;code>build&lt;/code> 也是经常见到的一个节点, 但我不是很理解它的作用.&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;!--项目信息--&amp;gt;
&amp;lt;groupId\&amp;gt;域名/项目名&amp;lt;/groupId\&amp;gt;
&amp;lt;artifactId\&amp;gt;项目名/组件&amp;lt;/artifactId\&amp;gt;
&amp;lt;version\&amp;gt;版本&amp;lt;/version\&amp;gt;
​
&amp;lt;properties\&amp;gt;
&amp;lt;!-- 可以声明编码 --&amp;gt;
&amp;lt;!-- 声明 jdk 版本--&amp;gt;
&amp;lt;maven.compiler.source\&amp;gt;1.8&amp;lt;/maven.compiler.source\&amp;gt;
&amp;lt;maven.compiler.target\&amp;gt;1.8&amp;lt;/maven.compiler.target\&amp;gt;
&amp;lt;!-- 可以自定义一些版本值 --&amp;gt;
&amp;lt;/properties\&amp;gt;
​
&amp;lt;!-- 一些构建相关的信息 --&amp;gt;
&amp;lt;build\&amp;gt;
……
&amp;lt;/build\&amp;gt;
​
&amp;lt;!-- 最重要的部分, 列出所依赖的包 --&amp;gt;
&amp;lt;dependencies\&amp;gt;
&amp;lt;dependency\&amp;gt;
&amp;lt;groupId\&amp;gt;域名/项目名&amp;lt;/groupId\&amp;gt;
&amp;lt;artifactId\&amp;gt;项目名/组件&amp;lt;/artifactId\&amp;gt;
&amp;lt;version\&amp;gt;版本&amp;lt;/version\&amp;gt;
&amp;lt;/dependency\&amp;gt;
……
&amp;lt;/dependencies\&amp;gt;
&lt;/code>&lt;/pre>&lt;p>同时, 和其他包管理工具相比, Maven 不像 pip、npm、gem 一样可以使用 &lt;code>install xxxx&lt;/code> 命令安装依赖, 而是需要自己向 &lt;code>pom.xml&lt;/code> 中添加 &lt;code>&amp;lt;dependency&amp;gt;……&amp;lt;/dependency&amp;gt;&lt;/code> 节点来添加依赖, 然后执行 &lt;code>mvn install&lt;/code> 命令才能安装.&lt;/p>
&lt;p>项目名, 包名, 版本号往往琐碎而难以记忆, 所以常常借用现有的 &lt;code>pom.xml&lt;/code> 文件; 或者像 &lt;code>Spring initializer&lt;/code> 一样生成 &lt;code>pom.xml&lt;/code> 文件; 同时也可以依赖搜索引擎, 比如说 &lt;a class="link" href="https://mvnrepository.com/" target="_blank" rel="noopener"
>Maven Repository Search&lt;/a> 就是一个很好用的 Maven 搜索工具.&lt;/p>
&lt;p>但在包管理之外, Maven 还可以进编译和打包, Maven 的使用大大简化了项目编译, 打包, 部署的工作量, 因为操作非常简单:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>运行是 &lt;code>mvn run&lt;/code>, 或者有一些特殊的项目可以定义特殊的启动方式, 如 &lt;code>mvn spring-boot:run&lt;/code> 命令;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>打包是 &lt;code>mvn package&lt;/code> , 打包之后产生的 &lt;code>fat jar package&lt;/code> 就可以通过 &lt;code>java -jar xx.jar&lt;/code> 来运行;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mvn clean&lt;/code> 命令可以删除掉项目中的 &lt;code>target&lt;/code> 文件夹, 也就是清除掉所有的编译后的内容.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="jsp-项目">JSP 项目&lt;/h3>
&lt;p>而对于传统的项目, 我以前并不太会使用 Maven 处理, 最近有需求之后有这些经验.&lt;/p>
&lt;p>一个JSP 项目的 Maven 的典型目录是 &lt;code>java&lt;/code>、&lt;code>resources&lt;/code>、&lt;code>webapp&lt;/code>. 在编译时, webapp 文件夹会成为根文件夹, &lt;code>java&lt;/code> 文件夹中代码会被编译成 &lt;code>.class&lt;/code> 文件放到 &lt;code>webapp/WEB-INF/lib&lt;/code> 中, &lt;code>resources&lt;/code> 文件夹和 &lt;code>java&lt;/code> 文件夹去的地方一样, 但因为是配置文件, 所以不会被编译.&lt;/p>
&lt;p>最最重要的一点, 就是 Maven 如何把这个项目识别成一个传统项目呢, 就是在项目信息下方添加 packaging 信息, 也就是 &lt;code>&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;&lt;/code>, 这样, Maven 就会识别 &lt;code>java&lt;/code>、&lt;code>resources&lt;/code>、&lt;code>webapp&lt;/code> 的结构了. 在拿到这样一个 xx.war 包之后, 把它拷贝到服务器 Tomcat 的 &lt;code>webapps&lt;/code> 文件夹下面, 重启 Tomcat 就可以成功部署.&lt;/p>
&lt;h3 id="spring-boot-项目">Spring Boot 项目&lt;/h3>
&lt;p>我 Spring Boot 相关的项目经验并不多, 仅有的经验是 Spring Boot 项目会在根目录产生 &lt;code>mvnw&lt;/code> 脚本, 通过该脚本, 可以使用 &lt;code>mvn spring-boot:run&lt;/code> 命令运行项目.&lt;/p>
&lt;p>因为 Spring Boot 项目往往具有共享的版本号, 所以可以添加 &lt;code>&amp;lt;parent&amp;gt;...&amp;lt;/parent&amp;gt;&lt;/code> 节点来一次性指定 Spring Boot 的版本, 之后可以省&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;parent\&amp;gt;
&amp;lt;groupId\&amp;gt;org.springframework.boot&amp;lt;/groupId\&amp;gt;
&amp;lt;artifactId\&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId\&amp;gt;
&amp;lt;version\&amp;gt;2.0.7.RELEASE&amp;lt;/version\&amp;gt;
&amp;lt;/parent\&amp;gt;
&lt;/code>&lt;/pre>&lt;p>略.&lt;/p>
&lt;p>PS: 在使用 &lt;code>mvn package&lt;/code> 时会要求数据库必须有连通性, 所以应当是本地打包完成后再在服务器部署使用.&lt;/p>
&lt;p>PS: &lt;code>mvn spring-boot:run&lt;/code> 命令为何可用, 是因为 添加以下插件带来的效果.&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;build\&amp;gt;
&amp;lt;plugins\&amp;gt;
&amp;lt;plugin\&amp;gt;
&amp;lt;groupId\&amp;gt;org.springframework.boot&amp;lt;/groupId\&amp;gt;
&amp;lt;artifactId\&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId\&amp;gt;
&amp;lt;/plugin\&amp;gt;
&amp;lt;/plugins\&amp;gt;
&amp;lt;/build\&amp;gt;
&lt;/code>&lt;/pre></description></item><item><title>项目反思</title><link>https://imzhizi.com/2017/11/%E9%A1%B9%E7%9B%AE%E5%8F%8D%E6%80%9D/</link><pubDate>Tue, 07 Nov 2017 00:55:29 +0800</pubDate><guid>https://imzhizi.com/2017/11/%E9%A1%B9%E7%9B%AE%E5%8F%8D%E6%80%9D/</guid><description>&lt;h2 id="一个小项目">一个小项目&lt;/h2>
&lt;p>实验室接了一个小项目, 是一个网站, 急着要用, 要求两周做完. 师兄找了我和另一个同学来做, 我做后端, 她做前端. 用什么写呢? 我在这个项目开始之前刚好学了一些 Python Web( Flask ), 看到了一些感觉很不错的特性, 所以我就想用 Python 写. 我是唯一的后端, 我说用 Python, 大家都不反对, 其实也无所谓吧. Python 写起来比 Java 确实要舒服一些, 语法更简洁, 很快就部署了起来. Flask 框架本身就非常小巧, 在 Java 上都属于框架的在 Python 通过几个很小的插件, 加几行代码就解决可以一个问题.&lt;/p>
&lt;p>这是个比较简单的项目, 但我完成的并不好, 甚至在项目上线的第三天, 我在半夜 1 点左右改了一个非常明显的 bug, 或许可以说出现 bug 很正常, 但那个 bug, 是因为那部分功能没测试. 我也不想再回顾, 先写下反思吧, 其他的以后有机会再说.&lt;/p>
&lt;h2 id="出现的问题">出现的问题&lt;/h2>
&lt;h3 id="写测试">写测试&lt;/h3>
&lt;p>如果没有刻意练习, 很难主动写测试, 整个项目我没写一行测试代码, 也出现了很多问题. 很多时候修改了某处代码, 而类似逻辑/用到同一部分的地方却忘记修改导致出现 bug, 这种情况发生过好几次, 但在改的时候又确实没想起来, 这时候如果有写好的测试, 跑一下立刻就知道改动是否有遗漏.&lt;/p>
&lt;h3 id="git-没意义">Git 没意义&lt;/h3>
&lt;p>项目使用了 Git, 但只有一个作用就是让我和前端稍微方便地合并代码 (其实还是面对面肉眼合并). 从 repo 建立到最终项目结束, 项目一直只有一个分支 commit 基本没什么道理, push 随意, 加上没有测试, head 上常常放着刚提交的 bug.&lt;/p>
&lt;h3 id="设计混乱">设计混乱&lt;/h3>
&lt;p>本身我也有认真设计数据库的, 但是因为只有我一个后端, 所以随着需求的变更, 数据库被我改造的越来越奇怪. 我用一个 int 字段来表示一个实体的不同状态, 每次状态改变都自增, 这个设计给后来编码带来了许多麻烦, 甚至带来了一个隐藏 bug 现在项目中还存在. 而这一切的源头就是我不愿意全盘考虑整个流程, 同时我懒得增加字段, 而是不断地给字段赋予新功能.&lt;/p>
&lt;p>跟 Java Web不同, Python Web 的实体不是 plain old object, 它被定义具有许多功能, 就比如说 Person 对象会自己告诉我它有几岁, 它的年薪多少, 它的孩子们都是谁, 这似乎是完全地面向对象. 受这种想法影响, 我在实体类中定义了大量各种功能的函数, 在路由层, 通过我拥有的对象的即可直接进行各种操作, 这种做法初衷很好. 但是需要对 OOP 仔细思考. 我设计的很差, 以至于后来我想要添加一个函数我都不知道应该写在哪里, 后来追加的 service.py 里面装满了各种我不知道应该放在哪里的各种中间函数, 我想如果他人看我的代码, 对于这个文件一定觉得莫名奇妙.&lt;/p>
&lt;h3 id="不会-python">不会 Python&lt;/h3>
&lt;p>其实在学 Flask 之前, 我甚至没怎么学过 Python, 对于 Python 的认识和 Go, Ruby 的认识一样多, 但我还是开始了这个项目. 对 Python的不理解表面上并没有给我带来什么难以解决的问题, 代码都是一样的写, 但更深层次上, 我常常用 Java 的方式在写 Python. 我能感觉到有一些做法是不恰当的, 但是能运行, 结果没什么异常也就作罢.&lt;/p>
&lt;h3 id="虚心">虚心&lt;/h3>
&lt;p>在项目中期, 需求没发生大变化之前, 主要的逻辑我都写好了, 不禁有些膨胀, 感觉有些洋洋得意, 这么快就写完了, 只要静静等前端就好了. 这直接导致我后来多次测试不认真, 多次出现测试过的代码仍然存在问题的情况.&lt;/p>
&lt;h2 id="感想">感想&lt;/h2>
&lt;h3 id="web-都差不多">Web 都差不多&lt;/h3>
&lt;p>Flask 也好, Spring 也罢, 大家都在做的事情是类似的, 做事情的方法也大差不差. 有很多做法都互相借鉴, 虽然没有使用, 但我在 Flask 里面也见到了依赖注入相关的内容, 虽然没用 Hibernate, 但 orm 的一些做法也都接近.&lt;/p>
&lt;h3 id="理解复杂">理解复杂&lt;/h3>
&lt;p>很多框架帮忙解决的地方, 都是复杂所在. 这些地方可能搞一些不知所谓的配置, 加几个类就有效果了, 但怎么产生效果是完全不知道. 这些地方确实没那么容易理解, 但是不容易理解的不是背后的原理, 而是实现的复杂. 很多看起来非常复杂的实现背后都是很简单的一些思路和方法, 但是实现看起来就是没那么容易理解. 所以要尽量去理解复杂, 把事情看开来.&lt;/p>
&lt;h3 id="flask-中的蓝图">Flask 中的蓝图&lt;/h3>
&lt;p>蓝图的概念很有意思, 在我理解, 每一个蓝图就是一个微缩的 Flask App, 如果不看数据, 它自己是自给自足的, 它的功能是内聚的, 然后多个蓝图组合在一起成为一个完整的网站.&lt;/p>
&lt;h3 id="view-model">View Model&lt;/h3>
&lt;p>很多时候实体的中拥有的字段并不是前端真正需要的, 它们需要的是处理过的, 保存过的数据实体, 这时候可以建一些 View Model 作为前后端传输数据的格式, 我猜想 Java 里面也有类似的设计, 但我还没看到.&lt;/p>
&lt;h3 id="url_forappindex">&lt;code>url_for('app.index')&lt;/code>&lt;/h3></description></item></channel></rss>